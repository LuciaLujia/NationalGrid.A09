---
title: "Forecasting- Carbon Intensity"
author: "A09"
date: "12/04/2021"
output: html_document
---

```{r}

# Libraries
library(readxl)
library(tidyverse)
library(ggplot2)
library(zoo) # For computing moving averages 
library(GGally)
library(caret) 
library(lubridate)
library(rsample)
library(tseries)
library(forecast)
library(vars)
library(car)
library(HDeconometrics)
library(scales)
library(TTR)
library(fpp2)
library(urca)
library(MTS)

```

### Load ,clean and reformat data

```{r}

#Import flow and generation data 2019-2020
flow_2020= read_excel("Flow 2020.xlsx", sheet=2, na="NA")
eu_2020= read_excel("EU 2020 .xlsx", sheet=2, na="NA")
flow_2019= read_excel("Flow 2019.xlsx", sheet=2, na="NA")
eu_2019= read_excel("EU 2019 .xlsx", sheet=2, na="NA")

# Import flow and generation data from 2016-2018
flow_1618 <- read_excel("flow_2016_2018.xlsx")
eu_1618 <- read_csv("EU 2016-18.csv")

# Load data on the carbon intensities of each generation technology
carbon_intensities <- read_excel("Technology CO2 Intensity.xlsx") 
carbon_intensities <- carbon_intensities[3, 2:21]

# Join data for 2020 and 2019
eu_1920 <- rbind(eu_2019, eu_2020) %>% 
# Remove negative generation, calculate total generation and compute difference between demand and generation
   mutate_at(3:23, function(x) ifelse(x<0,0,x)) 

# Make interconnector flows between GB and its neighbors consistent with the rest of the dataset
flow_2020 <- flow_2020 %>% 
  mutate(GB.FR= -FR.GB,
         GB.NL = -NL.GB,
         GB.BE= -BE.GB,
         GB.IE= -IE.GB,
         GB.NIR= -NIR.GB
         )

flow_2019 <- flow_2019 %>% 
  mutate(GB.FR= -FR.GB,
         GB.NL = -NL.GB,
         GB.BE= -BE.GB,
         GB.IE= -IE.GB,
         GB.NIR= -NIR.GB
         )

# Convert flow and generation data to monthly
flow_1920 <- as.data.frame(rbind(flow_2019, flow_2020)) %>%
  mutate(Datetime= floor_date(Datetime, "month")) %>% 
  group_by(Datetime) %>% 
  summarise_at(1:59, sum, na.rm=TRUE) 
  
  
eu_1920 <- eu_1920 %>% 
  mutate(Datetime= floor_date(Datetime, "month")) %>% 
  group_by(Datetime, Country) %>% 
  summarise_at(1:21, sum, na.rm=TRUE) 

eu_1618 <- eu_1618 %>% 
  mutate(Country= as.character(str_match_all(Country, "(?<=\\().+?(?=\\))")),
         Embedded.Wind=0,
         Embedded.other=0)

# Combine relevant interconnector flows
relevant_IF <- colnames(flow_1618)

flow_1920 <- flow_1920 %>% 
  dplyr::select(1,matches(relevant_IF))

# Combine interconnector flows 2016-2020
flow <- rbind(flow_1618, flow_1920)

# Combine generation for years 2016-2020
eu_1920_mod <- eu_1920 %>% 
  dplyr::select(-Demand) %>% 
  ungroup()

eu_generation <- rbind(eu_1618, eu_1920_mod)


```

## Initial Calculation of Carbon Intensity

```{r}

eu_1920_mod <- eu_1920 %>% 
  dplyr::select(-Demand) %>% 
  ungroup()

eu_generation <- rbind(eu_1618, eu_1920_mod)

# Percentage of total generation from each fuel/asset type-Monthly
eu_generation_percentage <- as.data.frame(cbind(eu_generation %>% dplyr::select(1:2), (eu_generation %>% dplyr::select(3:22))/rowSums((eu_generation %>% dplyr::select(3:22)))))

eu_generation_CI <- 
  eu_generation_percentage %>%
  dplyr::select(3:22)

eu_generation_CI <- cbind(eu_generation_percentage %>% dplyr::select(Datetime, Country), as.data.frame(mapply("*", eu_generation_CI, carbon_intensities)))

# Calculate the total monthly carbon intensity of each Megawatt hour of energy generated by each country (in kg/MWh or g/KWh)
eu_generation_CI <- 
  eu_generation_CI %>% 
  mutate(carbon_intensity = 1000*rowSums(dplyr::across(3:22), na.rm = T))

# Dataframe of hourly carbon intensities for each country

monthly_carbon_intensity <- eu_generation_CI %>% 
  dplyr::select(Datetime, Country, carbon_intensity) %>% 
  pivot_wider(names_from = "Country", values_from= "carbon_intensity")

monthly_generation <- eu_generation %>% 
  mutate(Generation= rowSums(dplyr::across(3:22), na.rm = T)) %>% 
  dplyr::select(Datetime, Country, Generation) %>% 
  pivot_wider(names_from = "Country", values_from= "Generation")

write_csv(monthly_carbon_intensity, "eu_monthly_carbon_intensity.csv")
write_csv(monthly_generation, "eu_monthly_generation.csv")

```

## Initial Calculation of Percentage of Green Energy

```{r}

green_energy_P <- eu_generation %>% 
  mutate(Generation= rowSums(dplyr::across(3:22), na.rm = T),
         Renewables= Geothermal+Hydro.Pumped.Storage+ Hydro.Run.of.river.and.poundage+
                  Hydro.Water.Reservoir+ Nuclear+ Solar+Wind.Offshore+Wind.Onshore+
                 Other.renewable+ Embedded.Wind,
         green_energy_percentage= (Renewables/Generation)*(100)) %>% 
  dplyr::select(Datetime, Country, green_energy_percentage) %>% 
  pivot_wider(names_from = "Country", values_from= "green_energy_percentage") 

write_csv(green_energy_P, "eu_monthly_green_energy.csv")

```


# Univariate Forecasting

```{r fig.height=8, fig.width=12}

# Function to calculate mape
mape <- function(actual,pred){
  mape <- mean(abs((actual - pred)/actual))*100
  return (mape)
}

```

```{r fig.height=8, fig.width=12}

eu_carbon_intensity <- read_xlsx("Total_Carbon_Intensity_2016-2020.xlsx", sheet=5)

# Examine Correlation Between the Final Carbon Intensities at each of the 14 countries
eu_carbon_intensity  %>% 
  dplyr::select(-1) %>% 
  ggcorr(method = c("pairwise", "pearson"), layout.exp = 2,label_round=2, label = TRUE,label_size = 2,hjust = 1,nbreaks = 5,size = 2,angle = -20)

# Visualize the change in carbon intensities over time- Great Britain
eu_carbon_intensity %>% 
  pivot_longer(cols=2:15, names_to="Country", values_to= "carbon_intensity") %>% 
  filter(Country=="GB") %>% 
  ggplot(aes(x=Datetime, y= carbon_intensity))+
  geom_line()

```

```{r fig.height=8, fig.width=12}

GB_data <- eu_carbon_intensity %>% dplyr::select(1,8)
# Split into training and test sets
GB_data_train <- GB_data[1:52,] 
GB_data_test <- GB_data[53:60,]

GB_ts <- ts(GB_data_train$GB, start = c(2016, 1), end = c(2020, 04), frequency = 12)
GB_ts_test <- ts(GB_data_test[, 2], start = c(2020, 5), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
GB_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation 
Acf(GB_ts, lag.max = 20)
Pacf(GB_ts, lag.max = 20)

#Evidence of autocorrelation at lags 1,2,3,10,11,12

# Checking whether the time-series is stationary or not using KPSS test
GB_ts %>% ur.kpss() %>% summary()

kpss.test(diff(GB_ts), null = c("Level", "Trend"), lshort = TRUE)

####################### 
# KPSS Unit Root Test # 
####################### 

#Test is of type: mu with 3 lags. 

#Value of test-statistic is: 0.9054 

#Critical value for a significance level of: 
#                10pct  5pct 2.5pct  1pct
#critical values 0.347 0.463  0.574 0.739

# Not stationary- needs differencing 

GB_ts %>% nsdiffs()
#  needs seasonal differencing of order 1 

```

```{r fig.height=8, fig.width=12}

# Naive model
model_naive <-snaive(GB_ts, h=8)
summary(model_naive)

for_naive <- forecast::forecast(model_naive, h = 8)
df_naive = as.data.frame(for_naive)
GB_data_test$naive = df_naive$`Point Forecast`
# Check MAPE of seasonal naive model
mape(GB_data_test$GB, GB_data_test$naive) # 12.60768

checkresiduals(model_naive)

#Ljung-Box test

#data:  Residuals from Seasonal naive method
#Q* = 20.434, df = 10, p-value = 0.0254

#Model df: 0.   Total lags used: 10


```

```{r fig.height=8, fig.width=12}

# Holt-Winters Seasonal Method (Multiplicative and Additive)

hw_a_model <- hw(GB_ts,seasonal="additive")

for_hwa <- forecast::forecast(hw_a_model, h = 8)
df_hwa = as.data.frame(for_hwa)
GB_data_test$hwa = df_hwa$`Point Forecast`
# Check MAPE of Holt-Winter's Additive Model
mape(GB_data_test$GB, GB_data_test$hwa)

checkresiduals(hw_a_model)

#Ljung-Box test

#data:  Residuals from Holt-Winters' additive method
#Q* = 55.804, df = 3, p-value = 4.625e-12

#Model df: 16.   Total lags used: 19

hw_m_model <- hw(GB_ts,seasonal="multiplicative")

for_hwm <- forecast::forecast(hw_m_model, h = 8)
df_hwm = as.data.frame(for_hwm)
GB_data_test$hwm = df_hwm$`Point Forecast`
# Check MAPE of Holt-Winter's Additive Model
mape(GB_data_test$GB, GB_data_test$hwm)

checkresiduals(hw_m_model)


```

```{r fig.height=8, fig.width=12}

# ARIMA
model_arima <- Arima(GB_ts, order=c(5,1,1),
  seasonal=c(2,1,1), lambda = 0)
summary(model_arima)

for_arima <- forecast::forecast(model_arima, h = 8)
df_arima = as.data.frame(for_arima)
GB_data_test$arima = df_arima$`Point Forecast`
mape(GB_data_test$GB, GB_data_test$arima)

# 0rder=c(5,1,1), seasonal=c(2,1,2), lambda=0 - #MAPE 6.892643 # AICc=-45.5
# 0rder=c(5,1,1), seasonal=c(2,1,1), lambda=0 - # MAPE 6.180747 # AICc=-48.72

checkresiduals(model_arima)

#autoplot(GB_ts) +
#  autolayer(for_arima)+
#  autolayer(GB_ts_test)

#plot(GB_ts)
#lines(fitted(model_arima), col="blue")



```

```{r fig.height=8, fig.width=12}


BE_data <- eu_carbon_intensity %>% 
  dplyr::select(1,15)

# Visualize the change in carbon intensities over time- Belgium
BE_data %>% 
  ggplot(aes(x=Datetime, y= BE))+
  geom_line()

# Split into training and test sets
BE_data_train <- BE_data[1:45,] 
BE_data_test <- BE_data[46:60,]

BE_ts <- ts(BE_data$BE, start = c(2016, 1), end = c(2019, 09), frequency = 12)
BE_ts_test <- ts(BE_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
BE_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation 
Acf(BE_ts, lag.max = 20)

#Evidence of autocorrelation at multiple lags

# Checking whether the time-series is stationary or not using KPSS test
BE_ts %>% ur.kpss() %>% summary()
kpss.test(BE_ts, null = c("Level", "Trend"), lshort = FALSE)

# Time series is stationary

BE_ts %>% nsdiffs()
#  1 seasonal difference 

# Naive model
model_naive <-snaive(BE_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
BE_data_test$naive = df_naive$`Point Forecast`
mape(BE_data_test$BE, BE_data_test$naive)  # 30.25098

checkresiduals(naive_mod)

# Holt-Winters Seasonal Method (Multiplicative and Additive)

hw_a_model <- hw(BE_ts,seasonal="additive")

for_hwa <- forecast::forecast(hw_a_model, h = 15)
df_hwa = as.data.frame(for_hwa)
BE_data_test$hwa = df_hwa$`Point Forecast`
# Check MAPE of Holt-Winter's Additive Model
mape(BE_data_test$BE, BE_data_test$hwa) #  24.89009

checkresiduals(hw_a_model)

hw_m_model <- hw(BE_ts,seasonal="multiplicative")

for_hwm <- forecast::forecast(hw_m_model, h = 15)
df_hwm = as.data.frame(for_hwm)
BE_data_test$hwm = df_hwm$`Point Forecast`
# Check MAPE of Holt-Winter's Multiplicative Model
mape(BE_data_test$BE, BE_data_test$hwm)  # 31.69228

checkresiduals(hw_m_model)


# Fitting an Arima model 

model_arima <- Arima(BE_ts, order=c(3,0,1),
  seasonal=c(1,1,0), lambda = 0)
summary(model_arima)

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
BE_data_test$arima = df_arima$`Point Forecast`
mape(BE_data_test$BE, BE_data_test$arima) #  24.90803

checkresiduals(model_arima)

#ARIMA(1,0,0)(1,1,0)[12] 

autoplot(BE_ts) +
  autolayer(for_arima)+
  autolayer(BE_ts_test)


```


```{r fig.height=8, fig.width=12}

NO_data <- eu_carbon_intensity %>% dplyr::select(1,13)

# Visualize the change in carbon intensities over time- Norway
NO_data %>% 
  ggplot(aes(x=Datetime, y= NO))+
  geom_line()

# Split into training and test sets
NO_data_train <- NO_data[1:45,] 
NO_data_test <- NO_data[46:60,]

NO_ts <- ts(NO_data$NO, start = c(2016, 1), end = c(2019, 09), frequency = 12)
NO_ts_test <- ts(NO_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
NO_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation 
Acf(NO_ts, lag.max = 20)

#Evidence of autocorrelation at lags 1,2

# Checking whether the time-series is stationary or not using KPSS test
NO_ts %>% ur.kpss() %>% summary()

####################### 
# KPSS Unit Root Test # 
####################### 

#Test is of type: mu with 3 lags. 

#Value of test-statistic is: 0.1493 

#Critical value for a significance level of: 
#                10pct  5pct 2.5pct  1pct
#critical values 0.347 0.463  0.574 0.739

NO_ts %>% nsdiffs()
#  seasonal differencing does not need to be done

# Naive model
model_naive <-snaive(NO_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
NO_data_test$naive = df_naive$`Point Forecast`
mape(NO_data_test$NO, NO_data_test$naive) # 92.00905

checkresiduals(naive_mod)

# Holt-Winters Seasonal Method (Multiplicative and Additive)

hw_a_model <- hw(NO_ts,seasonal="additive")

for_hwa <- forecast::forecast(hw_a_model, h = 15)
df_hwa = as.data.frame(for_hwa)
NO_data_test$hwa = df_hwa$`Point Forecast`
# Check MAPE of Holt-Winter's Additive Model
mape(NO_data_test$NO, NO_data_test$hwa) # 74.92197

checkresiduals(hw_a_model)

hw_m_model <- hw(NO_ts,seasonal="multiplicative")

for_hwm <- forecast::forecast(hw_m_model, h = 15)
df_hwm = as.data.frame(for_hwm)
NO_data_test$hwm = df_hwm$`Point Forecast`
# Check MAPE of Holt-Winter's Multiplicative Model
mape(NO_data_test$NO, NO_data_test$hwm)  # 77.67577

checkresiduals(hw_m_model)

# Fitting an Arima model 

model_arima <- Arima(NO_ts, order=c(4,1,0),
  seasonal=c(1,0,0), lambda = 1)
summary(model_arima)

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
NO_data_test$arima = df_arima$`Point Forecast`
mape(NO_data_test$NO, NO_data_test$arima) # 77.0192

checkresiduals(model_arima)


```

```{r fig.height=8, fig.width=12}


FR_data <- eu_carbon_intensity %>% 
  dplyr::select(1,7)

# Visualize the change in carbon intensities over time- France
FR_data %>% 
  ggplot(aes(x=Datetime, y= FR))+
  geom_line()

# Split into training and test sets
FR_data_train <- FR_data[1:45,] 
FR_data_test <- FR_data[46:60,]

FR_ts <- ts(FR_data$FR, start = c(2016, 1), end = c(2019, 09), frequency = 12)
FR_ts_test <- ts(FR_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
FR_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation 
Acf(FR_ts, lag.max = 20)
Pacf(FR_ts, lag.max = 20)

#Evidence of autocorrelation at multiple lags

# Checking whether the time-series is stationary or not using KPSS test
FR_ts %>% ur.kpss() %>% summary()

####################### 
# KPSS Unit Root Test # 
####################### 

#Test is of type: mu with 3 lags. 

#Value of test-statistic is: 0.1493 

#Critical value for a significance level of: 
#                10pct  5pct 2.5pct  1pct
#critical values 0.347 0.463  0.574 0.739

# The time series appears to be stationary

FR_ts %>% nsdiffs()
#  1 seasonal difference 

# Naive model
model_naive <-snaive(FR_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
FR_data_test$naive = df_naive$`Point Forecast`
mape(FR_data_test$FR, FR_data_test$naive)  # 34.03101

checkresiduals(naive_mod)

# Holt-Winters Seasonal Method (Multiplicative and Additive)

hw_a_model <- hw(FR_ts,seasonal="additive")

for_hwa <- forecast::forecast(hw_a_model, h = 15)
df_hwa = as.data.frame(for_hwa)
FR_data_test$hwa = df_hwa$`Point Forecast`
# Check MAPE of Holt-Winter's Additive Model
mape(FR_data_test$FR, FR_data_test$hwa) # 41.21512

checkresiduals(hw_a_model)

hw_m_model <- hw(FR_ts,seasonal="multiplicative")

for_hwm <- forecast::forecast(hw_m_model, h = 15)
df_hwm = as.data.frame(for_hwm)
FR_data_test$hwm = df_hwm$`Point Forecast`
# Check MAPE of Holt-Winter's Multiplicative Model
mape(FR_data_test$FR, FR_data_test$hwm)  # 35.86781

checkresiduals(hw_m_model)


# Fitting an Arima model 

model_arima <- auto.arima(FR_ts)
summary(model_arima)

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
FR_data_test$arima = df_arima$`Point Forecast`
mape(FR_data_test$FR, FR_data_test$arima) 

checkresiduals(model_arima)

# ARIMA(0,0,1)(1,1,0)[12] with drift # 33.25998




```

```{r fig.height=8, fig.width=12}

NL_data <- eu_carbon_intensity %>% 
  dplyr::select(1,12)

# Visualize the change in carbon intensities over time- France
NL_data %>% 
  ggplot(aes(x=Datetime, y= NL))+
  geom_line()

# Split into training and test sets
NL_data_train <- NL_data[1:45,] 
NL_data_test <- NL_data[46:60,]

NL_ts <- ts(NL_data$NL, start = c(2016, 1), end = c(2019, 09), frequency = 12)
NL_ts_test <- ts(NL_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
NL_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation 
Acf(NL_ts, lag.max = 20)
# Autocorrelation to lag 5 (decreasing)
Pacf(NL_ts, lag.max=20)
# Pacf at lag 1- Indicative of an autoregressive term of lag 1

# Checking whether the time-series is stationary or not using KPSS test
NL_ts %>% ur.kpss() %>% summary()
# Differencing is required- series is non-stationary

NL_ts %>% nsdiffs()
# No seasonal differencing 

# Naive model
model_naive <-snaive(NL_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
NL_data_test$naive = df_naive$`Point Forecast`
mape(NL_data_test$NL, NL_data_test$naive)  # 18.10423

checkresiduals(naive_mod)

# Holt-Winters Seasonal Method (Multiplicative and Additive)

hw_a_model <- hw(NL_ts,seasonal="additive")

for_hwa <- forecast::forecast(hw_a_model, h = 15)
df_hwa = as.data.frame(for_hwa)
NL_data_test$hwa = df_hwa$`Point Forecast`
# Check MAPE of Holt-Winter's Additive Model
mape(NL_data_test$NL, NL_data_test$hwa) # 12.85088

checkresiduals(hw_a_model)

hw_m_model <- hw(NL_ts,seasonal="multiplicative")

for_hwm <- forecast::forecast(hw_m_model, h = 15)
df_hwm = as.data.frame(for_hwm)
NL_data_test$hwm = df_hwm$`Point Forecast`
# Check MAPE of Holt-Winter's Multiplicative Model
mape(NL_data_test$NL, NL_data_test$hwm)  # 24.58347

checkresiduals(hw_m_model)


# Fitting an Arima model 

model_arima <- Arima(NL_ts, order=c(1,1,0),
  seasonal=c(1,0,0), lambda = 0)
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 60)
df_arima = as.data.frame(for_arima)
NL_data_test$arima = df_arima$`Point Forecast`
mape(NL_data_test$NL, NL_data_test$arima) 

checkresiduals(model_arima)

autoplot(NL_ts) +
  autolayer(for_arima)+
  autolayer(NL_ts_test)


```

```{r fig.height=8, fig.width=12}

DK_data <- eu_carbon_intensity %>% 
  dplyr::select(1,4)

# Visualize the change in carbon intensities over time- France
DK_data %>% 
  ggplot(aes(x=Datetime, y= DK))+
  geom_line()

# Split into training and test sets
DK_data_train <- DK_data[1:45,] 
DK_data_test <- DK_data[46:60,]

DK_ts <- ts(DK_data$DK, start = c(2016, 1), end = c(2019, 09), frequency = 12)
DK_ts_test <- ts(DK_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
DK_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation 
Acf(DK_ts, lag.max = 20)

Pacf(DK_ts, lag.max=20)


# Checking whether the time-series is stationary or not using KPSS test
DK_ts %>% ur.kpss() %>% summary()
# Non stationary- differencing will be needed

DK_ts %>% nsdiffs()

# Naive model
model_naive <-snaive(DK_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
DK_data_test$naive = df_naive$`Point Forecast`
mape(DK_data_test$DK, DK_data_test$naive) # 48.97638

checkresiduals(naive_mod)

# Holt-Winters Seasonal Method (Multiplicative and Additive)

hw_a_model <- hw(DK_ts,seasonal="additive")

for_hwa <- forecast::forecast(hw_a_model, h = 24)
df_hwa = as.data.frame(for_hwa)
DK_data_test$hwa = df_hwa$`Point Forecast`
# Check MAPE of Holt-Winter's Additive Model
mape(DK_data_test$DK, DK_data_test$hwa)# 45.01442

checkresiduals(hw_a_model)

hw_m_model <- hw(DK_ts,seasonal="multiplicative")

for_hwm <- forecast::forecast(hw_m_model, h = 15)
df_hwm = as.data.frame(for_hwm)
DK_data_test$hwm = df_hwm$`Point Forecast`
# Check MAPE of Holt-Winter's Multiplicative Model
mape(DK_data_test$DK, DK_data_test$hwm)  # 48.90951

checkresiduals(hw_m_model)

# Fitting an Arima model 

model_arima <- Arima(DK_ts, order=c(2,1,1),
  seasonal=c(1,0,0), lambda = 0)
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 60)
df_arima = as.data.frame(for_arima)
DK_data_test$arima = df_arima$`Point Forecast`
mape(DK_data_test$DK, DK_data_test$arima) # 26.05668

checkresiduals(model_arima)

autoplot(DK_ts) +
  autolayer(for_arima)+
  autolayer(DK_ts_test)

```






