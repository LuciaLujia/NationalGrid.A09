---
title: "Forecasting- Carbon Intensity"
author: "A09"
date: "12/04/2021"
output: html_document
---

```{r}

# Libraries
library(readxl)
library(tidyverse)
library(ggplot2)
library(zoo) # For computing moving averages 
library(GGally)
library(caret) 
library(lubridate)
library(rsample)
library(tseries)
library(forecast)
library(vars)
library(car)
library(HDeconometrics)
library(scales)
library(TTR)
library(fpp2)
library(urca)
library(MTS)

```

### Load ,clean and reformat data

```{r}

#Import flow and generation data 2019-2020
flow_2020= read_excel("Flow 2020.xlsx", sheet=2, na="NA")
eu_2020= read_excel("EU 2020 .xlsx", sheet=2, na="NA")
flow_2019= read_excel("Flow 2019.xlsx", sheet=2, na="NA")
eu_2019= read_excel("EU 2019 .xlsx", sheet=2, na="NA")

# Import flow and generation data from 2016-2018
flow_1618 <- read_excel("flow_2016_2018.xlsx")
eu_1618 <- read_csv("EU 2016-18.csv")

# Load data on the carbon intensities of each generation technology
carbon_intensities <- read_excel("Technology CO2 Intensity.xlsx") 
carbon_intensities <- carbon_intensities[3, 2:21]

# Join data for 2020 and 2019
eu_1920 <- rbind(eu_2019, eu_2020) %>% 
# Remove negative generation, calculate total generation and compute difference between demand and generation
   mutate_at(3:23, function(x) ifelse(x<0,0,x)) 

# Make interconnector flows between GB and its neighbors consistent with the rest of the dataset
flow_2020 <- flow_2020 %>% 
  mutate(GB.FR= -FR.GB,
         GB.NL = -NL.GB,
         GB.BE= -BE.GB,
         GB.IE= -IE.GB,
         GB.NIR= -NIR.GB
         )

flow_2019 <- flow_2019 %>% 
  mutate(GB.FR= -FR.GB,
         GB.NL = -NL.GB,
         GB.BE= -BE.GB,
         GB.IE= -IE.GB,
         GB.NIR= -NIR.GB
         )

# Convert flow and generation data to monthly
flow_1920 <- as.data.frame(rbind(flow_2019, flow_2020)) %>%
  mutate(Datetime= floor_date(Datetime, "month")) %>% 
  group_by(Datetime) %>% 
  summarise_at(1:59, sum, na.rm=TRUE) 
  
  
eu_1920 <- eu_1920 %>% 
  mutate(Datetime= floor_date(Datetime, "month")) %>% 
  group_by(Datetime, Country) %>% 
  summarise_at(1:21, sum, na.rm=TRUE) 

eu_1618 <- eu_1618 %>% 
  mutate(Country= as.character(str_match_all(Country, "(?<=\\().+?(?=\\))")),
         Embedded.Wind=0,
         Embedded.other=0)

# Combine relevant interconnector flows
relevant_IF <- colnames(flow_1618)

flow_1920 <- flow_1920 %>% 
  dplyr::select(1,matches(relevant_IF))

# Combine interconnector flows 2016-2020
flow <- rbind(flow_1618, flow_1920)

# Combine generation for years 2016-2020
eu_1920_mod <- eu_1920 %>% 
  dplyr::select(-Demand) %>% 
  ungroup()

eu_generation <- rbind(eu_1618, eu_1920_mod)


```

### Initial Calculation of Carbon Intensity

```{r}

eu_1920_mod <- eu_1920 %>% 
  dplyr::select(-Demand) %>% 
  ungroup()

eu_generation <- rbind(eu_1618, eu_1920_mod)

# Percentage of total generation from each fuel/asset type-Monthly
eu_generation_percentage <- as.data.frame(cbind(eu_generation %>% dplyr::select(1:2), (eu_generation %>% dplyr::select(3:22))/rowSums((eu_generation %>% dplyr::select(3:22)))))

eu_generation_CI <- 
  eu_generation_percentage %>%
  dplyr::select(3:22)

eu_generation_CI <- cbind(eu_generation_percentage %>% dplyr::select(Datetime, Country), as.data.frame(mapply("*", eu_generation_CI, carbon_intensities)))

# Calculate the total monthly carbon intensity of each Megawatt hour of energy generated by each country (in kg/MWh or g/KWh)
eu_generation_CI <- 
  eu_generation_CI %>% 
  mutate(carbon_intensity = 1000*rowSums(dplyr::across(3:22), na.rm = T))

# Dataframe of hourly carbon intensities for each country

monthly_carbon_intensity <- eu_generation_CI %>% 
  dplyr::select(Datetime, Country, carbon_intensity) %>% 
  pivot_wider(names_from = "Country", values_from= "carbon_intensity")

monthly_generation <- eu_generation %>% 
  mutate(Generation= rowSums(dplyr::across(3:22), na.rm = T)) %>% 
  dplyr::select(Datetime, Country, Generation) %>% 
  pivot_wider(names_from = "Country", values_from= "Generation")

write_csv(monthly_carbon_intensity, "eu_monthly_carbon_intensity.csv")
write_csv(monthly_generation, "eu_monthly_generation.csv")

```

### Initial Calculation of Percentage of Green Energy

```{r}

green_energy_P <- eu_generation %>% 
  mutate(Generation= rowSums(dplyr::across(3:22), na.rm = T),
         Renewables= Geothermal+Hydro.Pumped.Storage+ Hydro.Run.of.river.and.poundage+
                  Hydro.Water.Reservoir+ Nuclear+ Solar+Wind.Offshore+Wind.Onshore+
                 Other.renewable+ Embedded.Wind,
         green_energy_percentage= (Renewables/Generation)*(100)) %>% 
  dplyr::select(Datetime, Country, green_energy_percentage) %>% 
  pivot_wider(names_from = "Country", values_from= "green_energy_percentage") 

write_csv(green_energy_P, "eu_monthly_green_energy.csv")

```


### Univariate Forecasting for Carbon Intensity

```{r fig.height=8, fig.width=12}

# Function to calculate mape
mape <- function(actual,pred){
  mape <- mean(abs((actual - pred)/actual))*100
  return (mape)
}

```

```{r fig.height=8, fig.width=12}

eu_carbon_intensity <- read_xlsx("Total_Carbon_Intensity_2016-2020.xlsx", sheet=5)

# Examine Correlation Between the Final Carbon Intensities at each of the 14 countries
eu_carbon_intensity  %>% 
  dplyr::select(-1) %>% 
  ggcorr(method = c("pairwise", "pearson"), layout.exp = 2,label_round=2, label = TRUE,label_size = 2,hjust = 1,nbreaks = 5,size = 2,angle = -20)

# Visualize the change in carbon intensities over time- Great Britain
eu_carbon_intensity %>% 
  pivot_longer(cols=2:15, names_to="Country", values_to= "carbon_intensity") %>% 
  filter(Country=="GB") %>% 
  ggplot(aes(x=Datetime, y= carbon_intensity))+
  geom_line()

```

```{r fig.height=8, fig.width=12}

GB_data <- eu_carbon_intensity %>% dplyr::select(1,8)
# Split into training and test sets
GB_data_train <- GB_data[1:45,] 
GB_data_test <- GB_data[46:60,]

GB_ts <- ts(GB_data_train[, 2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
GB_ts_test <- ts(GB_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
GB_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation 
Acf(GB_ts, lag.max = 20)
Pacf(GB_ts, lag.max = 20)

#Evidence of autocorrelation at lags 1,2,10,11,12

# Checking whether the time-series is stationary or not using KPSS test
GB_ts %>% ur.kpss() %>% summary()

kpss.test(diff(GB_ts), null = c("Level", "Trend"), lshort = TRUE)

####################### 
# KPSS Unit Root Test # 
####################### 

#Test is of type: mu with 3 lags. 

#Value of test-statistic is: 0.9054 

#Critical value for a significance level of: 
#                10pct  5pct 2.5pct  1pct
#critical values 0.347 0.463  0.574 0.739

# Not stationary- needs differencing 

GB_ts %>% nsdiffs()
#  needs seasonal differencing of order 1 

```

```{r fig.height=8, fig.width=12}

# Naive model
model_naive <-snaive(GB_ts, h=15)
summary(model_naive)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
GB_data_test$naive = df_naive$`Point Forecast`
# Check MAPE of seasonal naive model
mape(GB_data_test$GB, GB_data_test$naive) #17.13656

checkresiduals(model_naive)




```


```{r fig.height=8, fig.width=12}

# ARIMA
model_arima <- Arima(GB_ts, order=c(5,1,1),
  seasonal=c(2,1,1), lambda = 0)
summary(model_arima)

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
GB_data_test$arima = df_arima$`Point Forecast`
mape(GB_data_test$GB, GB_data_test$arima) # 10.19661

# 0rder=c(5,1,1), seasonal=c(2,1,1), lambda=0 - # MAPE 10.19661 # AICc=-28.32

checkresiduals(model_arima)

# Generate forecasts uptill 2025

# Define a new dataframe to store values of the forecasts
values = seq(from = as.Date("2019-10-01"), to = as.Date("2025-12-01"), by = 'month')
eu_forecasts <- as.data.frame(values) %>% 
  rename(Datetime="values")

for_GB <- forecast::forecast(model_arima, h = 75)
df_for_GB = as.data.frame(for_GB)
eu_forecasts$GB = df_for_GB$`Point Forecast`



```

```{r fig.height=8, fig.width=12}


BE_data <- eu_carbon_intensity %>% 
  dplyr::select(1,15)

# Visualize the change in carbon intensities over time- Belgium
BE_data %>% 
  ggplot(aes(x=Datetime, y= BE))+
  geom_line()

# Split into training and test sets
BE_data_train <- BE_data[1:45,] 
BE_data_test <- BE_data[46:60,]

BE_ts <- ts(BE_data_train[, 2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
BE_ts_test <- ts(BE_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
BE_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation 
Acf(BE_ts, lag.max = 20)

#Evidence of autocorrelation at multiple lags

# Checking whether the time-series is stationary or not using KPSS test
BE_ts %>% ur.kpss() %>% summary()
kpss.test(BE_ts, null = c("Level", "Trend"), lshort = FALSE)

# Time series is stationary

BE_ts %>% nsdiffs()
#  1 seasonal difference 

# Naive model
model_naive <-snaive(BE_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
BE_data_test$naive = df_naive$`Point Forecast`
mape(BE_data_test$BE, BE_data_test$naive)  # 30.25098

checkresiduals(naive_mod)

# Fitting an Arima model 

model_arima <- Arima(BE_ts, order=c(3,0,1),
  seasonal=c(1,1,0), lambda = 0)
summary(model_arima)

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
BE_data_test$arima = df_arima$`Point Forecast`
mape(BE_data_test$BE, BE_data_test$arima) #  24.90803

checkresiduals(model_arima)

#ARIMA(1,0,0)(1,1,0)[12] 

# Add forecasts from Belgium to dataframe
for_BE <- forecast::forecast(model_arima, h = 75)
df_for_BE = as.data.frame(for_BE)
eu_forecasts$BE = df_for_BE$`Point Forecast`

autoplot(BE_ts) +
  autolayer(for_BE)+
  autolayer(BE_ts_test)


```


```{r fig.height=8, fig.width=12}

NO_data <- eu_carbon_intensity %>% dplyr::select(1,13)

# Visualize the change in carbon intensities over time- Norway
NO_data %>% 
  ggplot(aes(x=Datetime, y= NO))+
  geom_line()

# Split into training and test sets
NO_data_train <- NO_data[1:45,] 
NO_data_test <- NO_data[46:60,]

NO_ts <- ts(NO_data_train[, 2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
NO_ts_test <- ts(NO_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
NO_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation 
Acf(NO_ts, lag.max = 20)

#Evidence of autocorrelation at lags 1,2

# Checking whether the time-series is stationary or not using KPSS test
NO_ts %>% ur.kpss() %>% summary()

####################### 
# KPSS Unit Root Test # 
####################### 

#Test is of type: mu with 3 lags. 

#Value of test-statistic is: 0.1493 

#Critical value for a significance level of: 
#                10pct  5pct 2.5pct  1pct
#critical values 0.347 0.463  0.574 0.739

NO_ts %>% nsdiffs()
#  seasonal differencing does not need to be done

# Naive model
model_naive <-snaive(NO_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
NO_data_test$naive = df_naive$`Point Forecast`
mape(NO_data_test$NO, NO_data_test$naive) # 92.00905

checkresiduals(naive_mod)

# Fitting an Arima model 

model_arima <- Arima(NO_ts, order=c(2,1,1),
  seasonal=c(1,0,0), lambda = 0)
summary(model_arima)

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
NO_data_test$arima = df_arima$`Point Forecast`
mape(NO_data_test$NO, NO_data_test$arima) # 71.3707

checkresiduals(model_arima)

# Add forecasts from Norway to dataframe
for_NO <- forecast::forecast(model_arima, h = 75)
df_for_NO = as.data.frame(for_NO)
eu_forecasts$NO = df_for_NO$`Point Forecast`

autoplot(NO_ts) +
  autolayer(for_NO)+
  autolayer(NO_ts_test)


```

```{r fig.height=8, fig.width=12}

FR_data <- eu_carbon_intensity %>% 
  dplyr::select(1,7)

# Visualize the change in carbon intensities over time- France
FR_data %>% 
  ggplot(aes(x=Datetime, y= FR))+
  geom_line()

# Split into training and test sets
FR_data_train <- FR_data[1:45,] 
FR_data_test <- FR_data[46:60,]

FR_ts <- ts(FR_data_train[, 2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
FR_ts_test <- ts(FR_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
FR_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation 
Acf(FR_ts, lag.max = 20)
Pacf(FR_ts, lag.max = 20)

#Evidence of autocorrelation at multiple lags

# Checking whether the time-series is stationary or not using KPSS test
FR_ts %>% ur.kpss() %>% summary()

####################### 
# KPSS Unit Root Test # 
####################### 

#Test is of type: mu with 3 lags. 

#Value of test-statistic is: 0.1493 

#Critical value for a significance level of: 
#                10pct  5pct 2.5pct  1pct
#critical values 0.347 0.463  0.574 0.739

# The time series appears to be stationary

FR_ts %>% nsdiffs()
#  1 seasonal difference 

# Naive model
model_naive <-snaive(FR_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
FR_data_test$naive = df_naive$`Point Forecast`
mape(FR_data_test$FR, FR_data_test$naive)  # 34.03101

checkresiduals(naive_mod)

# Fitting an Arima model 

model_arima <- auto.arima(FR_ts)
summary(model_arima)

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
FR_data_test$arima = df_arima$`Point Forecast`
mape(FR_data_test$FR, FR_data_test$arima) 

checkresiduals(model_arima)

# ARIMA(0,0,1)(1,1,0)[12] with drift # 33.25998

# Add forecasts from France to dataframe
for_FR <- forecast::forecast(model_arima, h = 75)
df_for_FR = as.data.frame(for_FR)
eu_forecasts$FR = df_for_FR$`Point Forecast`

autoplot(FR_ts) +
  autolayer(for_FR)+
  autolayer(FR_ts_test)


```

```{r fig.height=8, fig.width=12}

NL_data <- eu_carbon_intensity %>% 
  dplyr::select(1,12)

# Visualize the change in carbon intensities over time- Netherlands
NL_data %>% 
  ggplot(aes(x=Datetime, y= NL))+
  geom_line()

# Split into training and test sets
NL_data_train <- NL_data[1:45,] 
NL_data_test <- NL_data[46:60,]

NL_ts <- ts(NL_data_train[, 2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
NL_ts_test <- ts(NL_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
NL_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation 
Acf(NL_ts, lag.max = 20)
# Autocorrelation to lag 5 (decreasing)
Pacf(NL_ts, lag.max=20)
# Pacf at lag 1- Indicative of an autoregressive term of lag 1

# Checking whether the time-series is stationary or not using KPSS test
NL_ts %>% ur.kpss() %>% summary()
# Differencing is required- series is non-stationary

NL_ts %>% nsdiffs()
# No seasonal differencing 

# Naive model
model_naive <-snaive(NL_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
NL_data_test$naive = df_naive$`Point Forecast`
mape(NL_data_test$NL, NL_data_test$naive)  # 18.10423

checkresiduals(naive_mod)

# Fitting an Arima model 

model_arima <- Arima(NL_ts, order=c(1,1,0),
  seasonal=c(1,0,0), lambda = 0)
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
NL_data_test$arima = df_arima$`Point Forecast`
mape(NL_data_test$NL, NL_data_test$arima) # 8.393567

checkresiduals(model_arima)


# Add forecasts from Netherlands to dataframe
for_NL <- forecast::forecast(model_arima, h = 75)
df_for_NL = as.data.frame(for_NL)
eu_forecasts$NL = df_for_NL$`Point Forecast`

autoplot(NL_ts) +
  autolayer(for_NL)+
  autolayer(NL_ts_test)


```

```{r fig.height=8, fig.width=12}

DK_data <- eu_carbon_intensity %>% 
  dplyr::select(1,4)

# Visualize the change in carbon intensities over time- Denmark
DK_data %>% 
  ggplot(aes(x=Datetime, y= DK))+
  geom_line()

# Split into training and test sets
DK_data_train <- DK_data[1:45,] 
DK_data_test <- DK_data[46:60,]

DK_ts <- ts(DK_data_train[, 2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
DK_ts_test <- ts(DK_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
DK_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation 
Acf(DK_ts, lag.max = 20)
Pacf(DK_ts, lag.max=20)

# Checking whether the time-series is stationary or not using KPSS test
DK_ts %>% ur.kpss() %>% summary()
# Non stationary- differencing will be needed

DK_ts %>% nsdiffs()

# Naive model
model_naive <-snaive(DK_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
DK_data_test$naive = df_naive$`Point Forecast`
mape(DK_data_test$DK, DK_data_test$naive) # 48.97638

checkresiduals(naive_mod)

# Fitting an Arima model 

model_arima <- Arima(DK_ts, order=c(2,1,1),
  seasonal=c(1,0,0), lambda = 0)
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
DK_data_test$arima = df_arima$`Point Forecast`
mape(DK_data_test$DK, DK_data_test$arima) # 26.05668

checkresiduals(model_arima)

# Add forecasts from Denmark to dataframe
for_DK <- forecast::forecast(model_arima, h = 75)
df_for_DK = as.data.frame(for_DK)
eu_forecasts$DK = df_for_DK$`Point Forecast`

autoplot(DK_ts) +
  autolayer(for_DK)+
  autolayer(DK_ts_test)


```

```{r fig.height=8, fig.width=12}

IE_data <- eu_carbon_intensity %>% 
  dplyr::select(1,9)

# Visualize the change in carbon intensities over time- Ireland
IE_data %>% 
  ggplot(aes(x=Datetime, y= IE))+
  geom_line()

# Split into training and test sets
IE_data_train <- IE_data[1:45,] 
IE_data_test <- IE_data[46:60,]

IE_ts <- ts(IE_data_train[, 2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
IE_ts_test <- ts(IE_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
IE_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation and partial autocorrelation
Acf(IE_ts, lag.max = 20)
Pacf(IE_ts, lag.max=20)
# p -order 3?

# Checking whether the time-series is stationary or not using KPSS test
IE_ts %>% ur.kpss() %>% summary()
# differencing will be needed 

IE_ts %>% nsdiffs()
# No seasonal differencing

# Naive model
model_naive <-snaive(IE_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
IE_data_test$naive = df_naive$`Point Forecast`
mape(IE_data_test$IE, IE_data_test$naive) # 21.99956

checkresiduals(naive_mod)

# Fitting an Arima model 

model_arima <- Arima(IE_ts, order=c(3,1,2),
  seasonal=c(0,1,1), lambda = 0.8)
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
IE_data_test$arima = df_arima$`Point Forecast`
mape(IE_data_test$IE, IE_data_test$arima) # 10.92296

checkresiduals(model_arima)

# Add forecasts from Ireland to dataframe
for_IE <- forecast::forecast(model_arima, h = 75)
df_for_IE = as.data.frame(for_IE)
eu_forecasts$IE = df_for_IE$`Point Forecast`

autoplot(IE_ts) +
  autolayer(for_IE)+
  autolayer(IE_ts_test)

eu_forecasts <- eu_forecasts %>% 
  mutate_at(2:8, function(x) ifelse(x<0,0,x)) %>% 
  slice(16:75)

write_csv(eu_forecasts,"eu_forecasts.csv")


```

### Univariate Forecasting of Green Energy Percentage

```{r fig.height=8, fig.width=12}

eu_green_percentage <- read_excel("Total_Renewable_Energy_2016-2020.xlsx", sheet=7)

GB_res_data <- eu_green_percentage %>% 
  dplyr::select(1,8)

# Visualize the change in green energy percentage over time- GB
GB_res_data %>% 
  ggplot(aes(x=Datetime, y= GB))+
  geom_line()

# Split into training and test sets
GB_res_data_train <- GB_res_data[1:45,] 
GB_res_data_test <- GB_res_data[46:60,]

GB_res_ts <- ts(GB_res_data_train[,2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
GB_res_ts_test <- ts(GB_res_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
GB_res_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation and partial autocorrelation
Acf(GB_res_ts, lag.max = 20)
Pacf(GB_res_ts, lag.max=20)

# Checking whether the time-series is stationary or not using KPSS test
GB_res_ts %>% ur.kpss() %>% summary()
# No differencing needed
GB_res_ts %>% nsdiffs()
# No seasonal differencing 

# Naive model
model_naive <-snaive(GB_res_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
GB_res_data_test$naive = df_naive$`Point Forecast`
mape(GB_res_data_test$GB, GB_res_data_test$naive) #  12.01992

checkresiduals(naive_mod)

# Fitting an Arima model 

model_arima <- Arima(GB_res_ts, order=c(2,0,1),
  seasonal=c(1,1,0), lambda = 0)
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
GB_res_data_test$arima = df_arima$`Point Forecast`
mape(GB_res_data_test$GB, GB_res_data_test$arima) # 9.803372

checkresiduals(model_arima)

# Define a new dataframe to store values of the forecasts
values = seq(from = as.Date("2019-10-01"), to = as.Date("2025-12-01"), by = 'month')
eu_res_forecasts <- as.data.frame(values) %>% 
  rename(Datetime="values")

for_GB <- forecast::forecast(model_arima, h = 75)
df_for_GB = as.data.frame(for_GB)
eu_res_forecasts$GB = df_for_GB$`Point Forecast`

autoplot(GB_res_ts) +
  autolayer(for_GB)+
  autolayer(GB_res_ts_test)

```

```{r fig.height=8, fig.width=12}

BE_res_data <- eu_green_percentage %>% 
  dplyr::select(1,15)

# Visualize the change in green energy percentage over time-Belgium
BE_res_data %>% 
  ggplot(aes(x=Datetime, y= BE))+
  geom_line()

# Split into training and test sets
BE_res_data_train <- BE_res_data[1:45,] 
BE_res_data_test <- BE_res_data[46:60,]

BE_res_ts <- ts(BE_res_data_train[,2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
BE_res_ts_test <- ts(BE_res_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
BE_res_ts %>% decompose(type="multiplicative") %>%
  autoplot() 


# Test for autocorrelation and partial autocorrelation
Acf(BE_res_ts, lag.max = 20)
Pacf(BE_res_ts, lag.max=20)

# Checking whether the time-series is stationary or not using KPSS test
BE_res_ts %>% ur.kpss() %>% summary()

BE_res_ts %>% nsdiffs()


# Naive model
model_naive <-snaive(BE_res_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
BE_res_data_test$naive = df_naive$`Point Forecast`
mape(BE_res_data_test$BE, BE_res_data_test$naive) 
checkresiduals(naive_mod) # 24.05762

# Fitting an Arima model 

model_arima <- Arima(BE_res_ts, order=c(1,0,0),
  seasonal=c(1,1,0))
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
BE_res_data_test$arima = df_arima$`Point Forecast`
mape(BE_res_data_test$BE, BE_res_data_test$arima) 

checkresiduals(model_arima)

# Add forecasts from BE to dataframe
for_BE <- forecast::forecast(model_arima, h = 75)
df_for_BE = as.data.frame(for_BE)
eu_res_forecasts$BE = df_for_BE$`Point Forecast`

autoplot(BE_res_ts) +
  autolayer(for_BE)+
  autolayer(BE_res_ts_test)


```

```{r fig.height=8, fig.width=12}


NO_res_data <- eu_green_percentage %>% 
  dplyr::select(1,13)

# Visualize the change in green energy percentage over time-Norway
NO_res_data %>% 
  ggplot(aes(x=Datetime, y= NO))+
  geom_line()

# Split into training and test sets
NO_res_data_train <- NO_res_data[1:45,] 
NO_res_data_test <- NO_res_data[46:60,]

NO_res_ts <- ts(NO_res_data_train[,2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
NO_res_ts_test <- ts(NO_res_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
NO_res_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation and partial autocorrelation
Acf(NO_res_ts, lag.max = 20)
Pacf(NO_res_ts, lag.max=20)

# Checking whether the time-series is stationary or not using KPSS test
NO_res_ts %>% ur.kpss() %>% summary()

NO_res_ts %>% nsdiffs()


# Naive model
model_naive <-snaive(NO_res_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
NO_res_data_test$naive = df_naive$`Point Forecast`
mape(NO_res_data_test$NO, NO_res_data_test$naive) # 3.15175
checkresiduals(naive_mod) 

# Fitting an Arima model 

model_arima <- Arima(NO_res_ts, order=c(1,1,1),
  seasonal=c(0,1,1))
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
NO_res_data_test$arima = df_arima$`Point Forecast`
mape(NO_res_data_test$NO, NO_res_data_test$arima) # 2.510672

checkresiduals(model_arima)


# Add forecasts from NO to dataframe
for_NO <- forecast::forecast(model_arima, h = 75)
df_for_NO = as.data.frame(for_NO)
eu_res_forecasts$NO = df_for_NO$`Point Forecast`

autoplot(NO_res_ts) +
  autolayer(for_NO)+
  autolayer(NO_res_ts_test)

eu_res_forecasts %>% 
  mutate(Datetime= floor_date(Datetime, "year")) %>% 
  group_by(Datetime) %>% 
  summarise_at(1:5, mean)


```

```{r fig.height=8, fig.width=12}

NL_res_data <- eu_green_percentage %>% 
  dplyr::select(1,12)

# Visualize the change in green energy percentage over time-Netherlands
NL_res_data %>% 
  ggplot(aes(x=Datetime, y= NL))+
  geom_line()

# Split into training and test sets
NL_res_data_train <- NL_res_data[1:45,] 
NL_res_data_test <- NL_res_data[46:60,]

NL_res_ts <- ts(NL_res_data_train[,2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
NL_res_ts_test <- ts(NL_res_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
NL_res_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation and partial autocorrelation
Acf(NL_res_ts, lag.max = 20)
Pacf(NL_res_ts, lag.max=20)

# Checking whether the time-series is stationary or not using KPSS test
NL_res_ts %>% ur.kpss() %>% summary()
NL_res_ts %>% nsdiffs()

# Naive model
model_naive <-snaive(NL_res_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
NL_res_data_test$naive = df_naive$`Point Forecast`
mape(NL_res_data_test$NL, NL_res_data_test$naive) # 28.65688
checkresiduals(naive_mod) 

# Fitting an Arima model 

model_arima <- Arima(NL_res_ts, order=c(2,1,2),
  seasonal=c(0,0,1))
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
NL_res_data_test$arima = df_arima$`Point Forecast`
mape(NL_res_data_test$NL, NL_res_data_test$arima) 

checkresiduals(model_arima)

# Add forecasts from NL to dataframe
for_NL <- forecast::forecast(model_arima, h = 75)
df_for_NL = as.data.frame(for_NL)
eu_res_forecasts$NL = df_for_NL$`Point Forecast`

autoplot(NL_res_ts) +
  autolayer(for_NL)+
  autolayer(NL_res_ts_test)


```
```{r fig.height=8, fig.width=12}

FR_res_data <- eu_green_percentage %>% 
  dplyr::select(1,7)

# Visualize the change in green energy percentage over time- France
FR_res_data %>% 
  ggplot(aes(x=Datetime, y= FR))+
  geom_line()

# Split into training and test sets
FR_res_data_train <- FR_res_data[1:45,] 
FR_res_data_test <- FR_res_data[46:60,]

FR_res_ts <- ts(FR_res_data_train[,2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
FR_res_ts_test <- ts(FR_res_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
FR_res_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation and partial autocorrelation
Acf(FR_res_ts, lag.max = 20)
Pacf(FR_res_ts, lag.max=20)

# Checking whether the time-series is stationary or not using KPSS test
FR_res_ts %>% ur.kpss() %>% summary()
FR_res_ts %>% nsdiffs()

# Naive model
model_naive <-snaive(FR_res_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
FR_res_data_test$naive = df_naive$`Point Forecast`
mape(FR_res_data_test$FR, FR_res_data_test$naive) # 1.803188
checkresiduals(naive_mod) 

# Fitting an Arima model 

model_arima <- auto.arima(FR_res_ts)
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
FR_res_data_test$arima = df_arima$`Point Forecast`
mape(FR_res_data_test$FR, FR_res_data_test$arima) # 2.565965

checkresiduals(model_arima)

# Add forecasts from FR to dataframe
for_FR <- forecast::forecast(model_arima, h = 75)
df_for_FR = as.data.frame(for_FR)
eu_res_forecasts$FR = df_for_FR$`Point Forecast`

autoplot(FR_res_ts) +
  autolayer(for_FR)+
  autolayer(FR_res_ts_test)


```

```{r fig.height=8, fig.width=12}


IE_res_data <- eu_green_percentage %>% 
  dplyr::select(1,9)

# Visualize the change in green energy percentage over time-Ireland
IE_res_data %>% 
  ggplot(aes(x=Datetime, y= IE))+
  geom_line()

# Split into training and test sets
IE_res_data_train <- IE_res_data[1:45,] 
IE_res_data_test <- IE_res_data[46:60,]

IE_res_ts <- ts(IE_res_data_train[,2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
IE_res_ts_test <- ts(IE_res_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
IE_res_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation and partial autocorrelation
Acf(IE_res_ts, lag.max = 20)
Pacf(IE_res_ts, lag.max=20)

# Checking whether the time-series is stationary or not using KPSS test
IE_res_ts %>% ur.kpss() %>% summary()
IE_res_ts %>% nsdiffs()

# Naive model
model_naive <-snaive(IE_res_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
IE_res_data_test$naive = df_naive$`Point Forecast`
mape(IE_res_data_test$IE, IE_res_data_test$naive) # 11.49514
checkresiduals(naive_mod) 

# Fitting an Arima model 

model_arima <- Arima(IE_res_ts, order=c(1,0,1),
  seasonal=c(1,1,0))
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
IE_res_data_test$arima = df_arima$`Point Forecast`
mape(IE_res_data_test$IE, IE_res_data_test$arima) 

checkresiduals(model_arima)

# Add forecasts from IE to dataframe
for_IE <- forecast::forecast(model_arima, h = 75)
df_for_IE = as.data.frame(for_IE)
eu_res_forecasts$IE = df_for_IE$`Point Forecast`

autoplot(IE_res_ts) +
  autolayer(for_IE)+
  autolayer(IE_res_ts_test)

eu_res_forecasts %>% 
  mutate(Datetime= floor_date(Datetime, "year")) %>% 
  group_by(Datetime) %>% 
  summarise_at(1:6, mean)

model_arima <- auto.arima(IE_res_ts)


```

```{r}

DK_res_data <- eu_green_percentage %>% 
  dplyr::select(1,4)

# Visualize the change in green energy percentage over time-Denmark
DK_res_data %>% 
  ggplot(aes(x=Datetime, y= DK))+
  geom_line()

# Split into training and test sets
DK_res_data_train <- DK_res_data[1:45,] 
DK_res_data_test <- DK_res_data[46:60,]

DK_res_ts <- ts(DK_res_data_train[,2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
DK_res_ts_test <- ts(DK_res_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
DK_res_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation and partial autocorrelation
Acf(DK_res_ts, lag.max = 20)
Pacf(DK_res_ts, lag.max=20)

# Checking whether the time-series is stationary or not using KPSS test
DK_res_ts %>% ur.kpss() %>% summary()
DK_res_ts %>% nsdiffs()

# Naive model
model_naive <-snaive(DK_res_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
DK_res_data_test$naive = df_naive$`Point Forecast`
mape(DK_res_data_test$DK, DK_res_data_test$naive) # 18.7683

checkresiduals(naive_mod) 

# Fitting an Arima model 

model_arima <- auto.arima(DK_res_ts)
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
DK_res_data_test$arima = df_arima$`Point Forecast`
mape(DK_res_data_test$DK, DK_res_data_test$arima) 

checkresiduals(model_arima)

# Add forecasts from DK to dataframe
for_DK <- forecast::forecast(model_arima, h = 75)
df_for_DK = as.data.frame(for_DK)
eu_res_forecasts$DK = df_for_DK$`Point Forecast`

autoplot(DK_res_ts) +
  autolayer(for_DK)+
  autolayer(DK_res_ts_test)


```


```{r}

DE_res_data <- eu_green_percentage %>% 
  dplyr::select(1,3)

# Visualize the change in green energy percentage over time- Germany
DE_res_data %>% 
  ggplot(aes(x=Datetime, y= DE))+
  geom_line()

# Split into training and test sets
DE_res_data_train <- DE_res_data[1:45,] 
DE_res_data_test <- DE_res_data[46:60,]

DE_res_ts <- ts(DE_res_data_train[,2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
DE_res_ts_test <- ts(DE_res_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
DE_res_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation and partial autocorrelation
Acf(DE_res_ts, lag.max = 20)
Pacf(DE_res_ts, lag.max=20)

# Checking whether the time-series is stationary or not using KPSS test
DE_res_ts %>% ur.kpss() %>% summary()
DE_res_ts %>% nsdiffs()

# Naive model
model_naive <-snaive(DE_res_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
DE_res_data_test$naive = df_naive$`Point Forecast`
mape(DE_res_data_test$DE, DE_res_data_test$naive)  # 9.328165

checkresiduals(naive_mod) 

# Fitting an Arima model 

model_arima <- Arima(DE_res_ts, order=c(4,0,1),
  seasonal=c(1,1,0))
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
DE_res_data_test$arima = df_arima$`Point Forecast`
mape(DE_res_data_test$DE, DE_res_data_test$arima)  # 8.387518

checkresiduals(model_arima)

# Add forecasts from DE to dataframe
for_DE <- forecast::forecast(model_arima, h = 75)
df_for_DE = as.data.frame(for_DE)
eu_res_forecasts$DE = df_for_DE$`Point Forecast`

autoplot(DE_res_ts) +
  autolayer(for_DE)+
  autolayer(DE_res_ts_test)

eu_res_forecasts %>% 
  mutate(Datetime= floor_date(Datetime, "year")) %>% 
  group_by(Datetime) %>% 
  summarise_at(1:8, mean)

```
```{r}

NIR_res_data <- eu_green_percentage %>% 
  dplyr::select(1,11)

# Visualize the change in green energy percentage over time- Germany
NIR_res_data %>% 
  ggplot(aes(x=Datetime, y= NIR))+
  geom_line()

# Split into training and test sets
NIR_res_data_train <- NIR_res_data[1:45,] 
NIR_res_data_test <- NIR_res_data[46:60,]

NIR_res_ts <- ts(NIR_res_data_train[,2], start = c(2016, 1), end = c(2019, 09), frequency = 12)
NIR_res_ts_test <- ts(NIR_res_data_test[, 2], start = c(2019, 10), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
NIR_res_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation and partial autocorrelation
Acf(NIR_res_ts, lag.max = 20)
Pacf(NIR_res_ts, lag.max=20)

# Checking whether the time-series is stationary or not using KPSS test
NIR_res_ts %>% ur.kpss() %>% summary()
NIR_res_ts %>% nsdiffs()

# Naive model
model_naive <-snaive(NIR_res_ts, h=15)

for_naive <- forecast::forecast(model_naive, h = 15)
df_naive = as.data.frame(for_naive)
NIR_res_data_test$naive = df_naive$`Point Forecast`
mape(NIR_res_data_test$NIR, NIR_res_data_test$naive)  # 2310.798

checkresiduals(naive_mod) 

# Fitting an Arima model 

model_arima <- auto.arima(NIR_res_ts)
summary(model_arima) 

for_arima <- forecast::forecast(model_arima, h = 15)
df_arima = as.data.frame(for_arima)
NIR_res_data_test$arima = df_arima$`Point Forecast`
mape(NIR_res_data_test$NIR, NIR_res_data_test$arima)  

checkresiduals(model_arima)

# Add forecasts from NIR to dataframe
for_NIR <- forecast::forecast(model_arima, h = 75)
df_for_NIR = as.data.frame(for_NIR)
eu_res_forecasts$NIR = df_for_NIR$`Point Forecast`

autoplot(NIR_res_ts) +
  autolayer(for_NIR)+
  autolayer(NIR_res_ts_test)

eu_res_forecasts %>% 
  mutate(Datetime= floor_date(Datetime, "year")) %>% 
  group_by(Datetime) %>% 
  summarise_at(1:8, mean)



```


