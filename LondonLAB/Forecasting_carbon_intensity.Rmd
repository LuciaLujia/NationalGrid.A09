---
title: "Forecasting- Carbon Intensity"
author: "A09"
date: "12/04/2021"
output: html_document
---

```{r}

# Libraries
library(readxl)
library(tidyverse)
library(ggplot2)
library(zoo) # For computing moving averages 
library(GGally)
library(caret) 
library(lubridate)
library(rsample)
library(tseries)
library(forecast)
library(vars)
library(car)
library(HDeconometrics)
library(scales)
library(TTR)
library(fpp2)
library(urca)
library(MTS)

```

### Load ,clean and reformat data

```{r}
#Import flow and generation data 2019-2020
flow_2020= read_excel("Flow 2020.xlsx", sheet=2, na="NA")
eu_2020= read_excel("EU 2020 .xlsx", sheet=2, na="NA")
flow_2019= read_excel("Flow 2019.xlsx", sheet=2, na="NA")
eu_2019= read_excel("EU 2019 .xlsx", sheet=2, na="NA")

# Import flow and generation data from 2016-2018
flow_1618 <- read_excel("flow_2016_2018.xlsx")
eu_1618 <- read_csv("EU 2016-18.csv")

# Load data on the carbon intensities of each generation technology
carbon_intensities <- read_excel("Technology CO2 Intensity.xlsx") 
carbon_intensities <- carbon_intensities[3, 2:21]

# Join data for 2020 and 2019
eu_1920 <- rbind(eu_2019, eu_2020) %>% 
# Remove negative generation, calculate total generation and compute difference between demand and generation
   mutate_at(3:23, function(x) ifelse(x<0,0,x)) 

# Make interconnector flows between GB and its neighbors consistent with the rest of the dataset
flow_2020 <- flow_2020 %>% 
  mutate(GB.FR= -FR.GB,
         GB.NL = -NL.GB,
         GB.BE= -BE.GB,
         GB.IE= -IE.GB,
         GB.NIR= -NIR.GB
         )

flow_2019 <- flow_2019 %>% 
  mutate(GB.FR= -FR.GB,
         GB.NL = -NL.GB,
         GB.BE= -BE.GB,
         GB.IE= -IE.GB,
         GB.NIR= -NIR.GB
         )

# Convert flow and generation data to monthly
flow_1920 <- as.data.frame(rbind(flow_2019, flow_2020)) %>%
  mutate(Datetime= floor_date(Datetime, "month")) %>% 
  group_by(Datetime) %>% 
  summarise_at(1:59, sum, na.rm=TRUE) 
  
  
eu_1920 <- eu_1920 %>% 
  mutate(Datetime= floor_date(Datetime, "month")) %>% 
  group_by(Datetime, Country) %>% 
  summarise_at(1:21, sum, na.rm=TRUE) 

eu_1618 <- eu_1618 %>% 
  mutate(Country= as.character(str_match_all(Country, "(?<=\\().+?(?=\\))")),
         Embedded.Wind=0,
         Embedded.other=0)

# Combine relevant interconnector flows
relevant_IF <- colnames(flow_1618)

flow_1920 <- flow_1920 %>% 
  dplyr::select(1,matches(relevant_IF))

# Combine interconnector flows 2016-2020
flow <- rbind(flow_1618, flow_1920)

# Combine generation for years 2016-2020
eu_1920_mod <- eu_1920 %>% 
  dplyr::select(-Demand) %>% 
  ungroup()

eu_generation <- rbind(eu_1618, eu_1920_mod)


```

## Initial Calculation of Carbon Intensity

```{r}

eu_1920_mod <- eu_1920 %>% 
  dplyr::select(-Demand) %>% 
  ungroup()

eu_generation <- rbind(eu_1618, eu_1920_mod)

# Percentage of total generation from each fuel/asset type-Monthly
eu_generation_percentage <- as.data.frame(cbind(eu_generation %>% dplyr::select(1:2), (eu_generation %>% dplyr::select(3:22))/rowSums((eu_generation %>% dplyr::select(3:22)))))

eu_generation_CI <- 
  eu_generation_percentage %>%
  dplyr::select(3:22)

eu_generation_CI <- cbind(eu_generation_percentage %>% dplyr::select(Datetime, Country), as.data.frame(mapply("*", eu_generation_CI, carbon_intensities)))

# Calculate the total monthly carbon intensity of each Megawatt hour of energy generated by each country (in kg/MWh or g/KWh)
eu_generation_CI <- 
  eu_generation_CI %>% 
  mutate(carbon_intensity = 1000*rowSums(dplyr::across(3:22), na.rm = T))

# Dataframe of hourly carbon intensities for each country

monthly_carbon_intensity <- eu_generation_CI %>% 
  dplyr::select(Datetime, Country, carbon_intensity) %>% 
  pivot_wider(names_from = "Country", values_from= "carbon_intensity")

monthly_generation <- eu_generation %>% 
  mutate(Generation= rowSums(dplyr::across(3:22), na.rm = T)) %>% 
  dplyr::select(Datetime, Country, Generation) %>% 
  pivot_wider(names_from = "Country", values_from= "Generation")

write_csv(monthly_carbon_intensity, "eu_monthly_carbon_intensity.csv")
write_csv(monthly_generation, "eu_monthly_generation.csv")

```

## Initial Calculation of Percentage of Green Energy

```{r}

green_energy_P <- eu_generation %>% 
  mutate(Generation= rowSums(dplyr::across(3:22), na.rm = T),
         Renewables= Geothermal+Hydro.Pumped.Storage+ Hydro.Run.of.river.and.poundage+
                  Hydro.Water.Reservoir+ Nuclear+ Solar+Wind.Offshore+Wind.Onshore+
                 Other.renewable+ Embedded.Wind,
         green_energy_percentage= (Renewables/Generation)*(100)) %>% 
  dplyr::select(Datetime, Country, green_energy_percentage) %>% 
  pivot_wider(names_from = "Country", values_from= "green_energy_percentage") 

write_csv(green_energy_P, "eu_monthly_green_energy.csv")

```


# Univariate Forecasting

```{r fig.height=8, fig.width=12}

# Function to calculate mape
mape <- function(actual,pred){
  mape <- mean(abs((actual - pred)/actual))*100
  return (mape)
}


```

```{r fig.height=8, fig.width=12}

eu_carbon_intensity <- read_xlsx("Total_Carbon_Intensity_2016-2020.xlsx", sheet=5)

# Examine Correlation Between the Final Carbon Intensities at each of the 14 countries
eu_carbon_intensity  %>% 
  dplyr::select(-1) %>% 
  ggcorr(method = c("pairwise", "pearson"), layout.exp = 2,label_round=2, label = TRUE,label_size = 2,hjust = 1,nbreaks = 5,size = 2,angle = -20)

# Visualize the change in carbon intensities over time- Great Britain
eu_carbon_intensity %>% 
  pivot_longer(cols=2:15, names_to="Country", values_to= "carbon_intensity") %>% 
  filter(Country=="GB") %>% 
  ggplot(aes(x=Datetime, y= carbon_intensity))+
  geom_line()

```

```{r fig.height=8, fig.width=12}

GB_data <- eu_carbon_intensity %>% dplyr::select(1,8)
# Split into training and test sets
GB_data_train <- GB_data[1:52,] 
GB_data_test <- GB_data[53:60,]

GB_ts <- ts(GB_data_train$GB, start = c(2016, 1), end = c(2020, 04), frequency = 12)
GB_ts_test <- ts(GB_data_test[, 2], start = c(2020, 5), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
GB_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

#Seasonal and Trend decomposition using Loess
STL <- GB_ts%>%
  stl(t.window=13, s.window="periodic", robust=TRUE) 

STL %>% forecast() %>%
  autoplot() 

# Box-Cox transformations
#lambda <- BoxCox.lambda(GB_ts)
#autoplot(BoxCox(GB_ts,lambda))

# Test for autocorrelation 
Acf(GB_ts, lag.max = 20)

#Evidence of autocorrelation at lags 0,1,2,10,11,12

# Checking whether the time-series is stationary or not using KPSS test
GB_ts %>% ur.kpss() %>% summary()

####################### 
# KPSS Unit Root Test # 
####################### 

#Test is of type: mu with 3 lags. 

#Value of test-statistic is: 0.9054 

#Critical value for a significance level of: 
#                10pct  5pct 2.5pct  1pct
#critical values 0.347 0.463  0.574 0.739

#p value is >0.05 and hence no differencing is needed since we cannot reject the null hypothesis of stationarity 

GB_ts %>% log() %>% diff(lag=12) %>% nsdiffs()
#  seasonal differencing should be done 

```

```{r fig.height=8, fig.width=12}

# Naive model
model_naive <-snaive(GB_ts, h=8)

for_naive <- forecast::forecast(model_naive, h = 8)
df_naive = as.data.frame(for_naive)
GB_data_test$naive = df_naive$`Point Forecast`
mape(GB_data_test$GB, GB_data_test$naive) 

checkresiduals(naive_mod)

```

```{r fig.height=8, fig.width=12}

# Holt-Winters Seasonal Method

hw_a <- hw(GB_ts,seasonal="additive")
hw_m<- hw(GB_ts,seasonal="multiplicative")

autoplot(GB_ts) +
  autolayer(GB_ts_test)+
  autolayer(hw_a, series="HW additive forecasts", PI=TRUE) +
  autolayer(hw_m, series="HW multiplicative forecasts",
    PI=TRUE) 

# Fitting ETS models to GB_ts 

etsfc <- GB_ts %>% 
  ets(model="MAA", damped=FALSE) 

summary(etsfc)
autoplot(etsfc)

for_ets <- etsfc %>% forecast(h=8) 
df_ets = as.data.frame(for_ets)
GB_data_test$ets = df_ets$`Point Forecast`
mape(GB_data_test$GB, GB_data_test$ets)


# MAM - 15.78644 
# AAA -15.87609
# MAA - 15.81459


```

```{r fig.height=8, fig.width=12}

# ARIMA
model_arima <- Arima(GB_ts, order=c(5,1,1),
  seasonal=c(2,1,1), lambda = 0)
summary(model_arima)
plot(GB_ts)
lines(fitted(model_arima), col="blue")

for_arima <- forecast::forecast(model_arima, h = 8)
df_arima = as.data.frame(for_arima)
GB_data_test$arima = df_arima$`Point Forecast`
mape(GB_data_test$GB, GB_data_test$arima) 

# 0rder=c(5,1,1), seasonal=c(2,1,2), lambda=0 - #MAPE 6.892643 # AICc=-45.5
# 0rder=c(5,1,1), seasonal=c(2,1,1), lambda=0 - # MAPE 6.180747 # AICc=-48.72

res <- residuals(model_arima)
autoplot(res) + ylab("") 
ggAcf(res) + ggtitle("ACF of residuals")
gghistogram(res) + ggtitle("Histogram of residuals")
Box.test(res, lag=10, fitdf=0)
Box.test(res,lag=12, fitdf=0, type="Lj")
checkresiduals(model_arima)

autoplot(GB_ts) +
  autolayer(for_arima)+
  autolayer(GB_ts_test)
  

#TBATS
model_tbats <- tbats(GB_ts)
summary(model_tbats)

for_tbats <- forecast::forecast(model_tbats, h = 8)
df_tbats = as.data.frame(for_tbats)
GB_data_test$tbats = df_tbats$`Point Forecast`
mape(GB_data_test$GB, GB_data_test$tbats) # 13.33593

ggplot(data=GB_data_test, aes(x=Datetime, y= GB), color= "black") +
  geom_line()+
  geom_line(aes(x=Datetime, y= tbats), color= "red")

rbind.data.frame(past_data,forecast_data) %>% 
  ggplot(aes(x=Datetime, y=GB))+
  geom_line()

```

```{r fig.height=8, fig.width=12}

NO_data <- eu_carbon_intensity %>% dplyr::select(1,13)

# Visualize the change in carbon intensities over time- Great Britain
NO_data %>% 
  ggplot(aes(x=Datetime, y= NO))+
  geom_line()

# Split into training and test sets
NO_data_train <- NO_data[1:52,] 
NO_data_test <- NO_data[53:60,]

NO_ts <- ts(NO_data_train$NO, start = c(2016, 1), end = c(2020, 04), frequency = 12)
NO_ts_test <- ts(NO_data_test[, 2], start = c(2020, 5), end = c(2020, 12), frequency = 12)

# Decompose time series- multiplicative: Classical Decomposition
NO_ts %>% decompose(type="multiplicative") %>%
  autoplot() 

# Test for autocorrelation 
Acf(NO_ts, lag.max = 20)

#Evidence of autocorrelation at lags 0,1,16,17,18,19

# Checking whether the time-series is stationary or not using KPSS test
NO_ts %>% ur.kpss() %>% summary()

####################### 
# KPSS Unit Root Test # 
####################### 

#Test is of type: mu with 3 lags. 

#Value of test-statistic is: 0.1493 

#Critical value for a significance level of: 
#                10pct  5pct 2.5pct  1pct
#critical values 0.347 0.463  0.574 0.739

NO_ts %>% nsdiffs()
#  seasonal differencing does not need to be done

# Naive model
model_naive <-snaive(NO_ts, h=8)

for_naive <- forecast::forecast(model_naive, h = 8)
df_naive = as.data.frame(for_naive)
NO_data_test$naive = df_naive$`Point Forecast`
mape(NO_data_test$NO, NO_data_test$naive) 

checkresiduals(naive_mod)

# Fitting ETS models to NO_ts 
etsfc <- NO_ts %>% 
  ets(model="MAM", damped=FALSE) 

summary(etsfc)
autoplot(etsfc)

for_ets <- etsfc %>% forecast(h=8) 
df_ets = as.data.frame(for_ets)
NO_data_test$ets = df_ets$`Point Forecast`
mape(NO_data_test$NO, NO_data_test$ets)

# Fitting an Arima model 

model_arima <- Arima(NO_ts, order=c(0,1,1),
  seasonal=c(0,0,1), lambda = 0)
summary(model_arima)
plot(NO_ts)
lines(fitted(model_arima), col="blue")

for_arima <- forecast::forecast(model_arima, h = 8)
df_arima = as.data.frame(for_arima)
NO_data_test$arima = df_arima$`Point Forecast`
mape(NO_data_test$NO, NO_data_test$arima) 

checkresiduals(model_arima)


```







