---
title: "Forecasting- Carbon Intensity"
author: "A09"
date: "12/04/2021"
output: html_document
---

```{r}

# Libraries
library(readxl)
library(tidyverse)
library(ggplot2)
library(zoo) # For computing moving averages 
library(GGally)
library(caret) 
library(lubridate)
library(rsample)
library(tseries)
library(forecast)
library(vars)
library(car)
library(HDeconometrics)
library(scales)
library(TTR)
library(fpp2)

```

### Load ,clean and reformat data

```{r}
#Import flow and generation data 2019-2020
flow_2020= read_excel("Flow 2020.xlsx", sheet=2, na="NA")
eu_2020= read_excel("EU 2020 .xlsx", sheet=2, na="NA")
flow_2019= read_excel("Flow 2019.xlsx", sheet=2, na="NA")
eu_2019= read_excel("EU 2019 .xlsx", sheet=2, na="NA")

# Import flow and generation data from 2016-2018
flow_1618 <- read_excel("flow_2016_2018.xlsx")
eu_1618 <- read_csv("EU 2016-18.csv")

# Import demand data for France
demand_1618 <- read_csv("Demand_FR.csv")

# Load data on the carbon intensities of each generation technology
carbon_intensities <- read_excel("Technology CO2 Intensity.xlsx") 
carbon_intensities <- carbon_intensities[3, 2:21]

# Join data for 2020 and 2019
eu_1920 <- rbind(eu_2019, eu_2020) %>% 
# Remove negative generation, calculate total generation and compute difference between demand and generation
   mutate_at(3:23, function(x) ifelse(x<0,0,x)) 

# Make interconnector flows between GB and its neighbors consistent with the rest of the dataset
flow_2020 <- flow_2020 %>% 
  mutate(GB.FR= -FR.GB,
         GB.NL = -NL.GB,
         GB.BE= -BE.GB,
         GB.IE= -IE.GB,
         GB.NIR= -NIR.GB
         )

flow_2019 <- flow_2019 %>% 
  mutate(GB.FR= -FR.GB,
         GB.NL = -NL.GB,
         GB.BE= -BE.GB,
         GB.IE= -IE.GB,
         GB.NIR= -NIR.GB
         )

# Convert flow and generation data to monthly
flow_1920 <- as.data.frame(rbind(flow_2019, flow_2020)) %>%
  mutate(Datetime= floor_date(Datetime, "month")) %>% 
  group_by(Datetime) %>% 
  summarise_at(1:59, sum, na.rm=TRUE) 
  
  
eu_1920 <- eu_1920 %>% 
  mutate(Datetime= floor_date(Datetime, "month")) %>% 
  group_by(Datetime, Country) %>% 
  summarise_at(1:21, sum, na.rm=TRUE) 

eu_1618 <- eu_1618 %>% 
  mutate(Country= as.character(str_match_all(Country, "(?<=\\().+?(?=\\))")),
         Embedded.Wind=0,
         Embedded.other=0)

# Combine relevant interconnector flows
relevant_IF <- colnames(flow_1618)

flow_1920 <- flow_1920 %>% 
  dplyr::select(1,matches(relevant_IF))

# Combine interconnector flows 2016-2020
flow <- rbind(flow_1618, flow_1920)

# Combine generation for years 2016-2020
eu_1920_mod <- eu_1920 %>% 
  dplyr::select(-Demand) %>% 
  ungroup()

eu_generation <- rbind(eu_1618, eu_1920_mod)


```

## Initial Calculation of Carbon Intensity

```{r}

eu_1920_mod <- eu_1920 %>% 
  dplyr::select(-Demand) %>% 
  ungroup()

eu_generation <- rbind(eu_1618, eu_1920_mod)

# Percentage of total generation from each fuel/asset type-Monthly
eu_generation_percentage <- as.data.frame(cbind(eu_generation %>% select(1:2), (eu_generation %>% select(3:22))/rowSums((eu_generation %>% select(3:22)))))

eu_generation_CI <- 
  eu_generation_percentage %>%
  select(3:22)

eu_generation_CI <- cbind(eu_generation_percentage %>% select(Datetime, Country), as.data.frame(mapply("*", eu_generation_CI, carbon_intensities)))

# Calculate the total monthly carbon intensity of each Megawatt hour of energy generated by each country (in kg/MWh or g/KWh)
eu_generation_CI <- 
  eu_generation_CI %>% 
  mutate(carbon_intensity = 1000*rowSums(dplyr::across(3:22), na.rm = T))

# Dataframe of hourly carbon intensities for each country

monthly_carbon_intensity <- eu_generation_CI %>% 
  select(Datetime, Country, carbon_intensity) %>% 
  pivot_wider(names_from = "Country", values_from= "carbon_intensity")

monthly_generation <- eu_generation %>% 
  mutate(Generation= rowSums(dplyr::across(3:22), na.rm = T)) %>% 
  select(Datetime, Country, Generation) %>% 
  pivot_wider(names_from = "Country", values_from= "Generation")

write_csv(monthly_carbon_intensity, "eu_monthly_carbon_intensity.csv")
write_csv(monthly_generation, "eu_monthly_generation.csv")

```

## Initial Calculation of Percentage of Green Energy

```{r}

green_energy_P <- eu_generation %>% 
  mutate(Generation= rowSums(dplyr::across(3:22), na.rm = T),
         Renewables= Geothermal+Hydro.Pumped.Storage+ Hydro.Run.of.river.and.poundage+
                  Hydro.Water.Reservoir+ Nuclear+ Solar+Wind.Offshore+Wind.Onshore+
                 Other.renewable+ Embedded.Wind,
         green_energy_percentage= (Renewables/Generation)*(100)) %>% 
  select(Datetime, Country, green_energy_percentage) %>% 
  pivot_wider(names_from = "Country", values_from= "green_energy_percentage") 

write_csv(green_energy_P, "eu_monthly_green_energy.csv")

```



```{r fig.height=8, fig.width=12}

# Collating monthly data for France

FR_data <- eu_generation %>%
filter(Country=="FR")

```


### Vector Autoregression

#### Daily Data

```{r fig.height=8, fig.width=12}

GB_data <- read_excel("GB_Data.xlsx", sheet=1) %>% 
  mutate(Datetime= floor_date(ymd_hms(Datetime),"day")) 

GB_original_data <- GB_data %>% 
  group_by(Datetime) %>% 
  summarise_at(1:12, sum) 

GB_data <- GB_data %>% 
  group_by(Datetime) %>% 
  summarise_at(1:12, sum) %>% 
  dplyr::select(-1)

# Split into training and test sets
GB_data_train <- GB_data[1:650,]
GB_data_test <- GB_data[651:731,]

# Run the augmented dickey-fuller test on all time-series to check for stationarity
apply(GB_data_train,2,adf.test)

# Difference each time series to make them all stationary 
GB_data_train <- as.data.frame(apply(GB_data_train,2, diff, differences = 1))

lagselect <- VARselect(GB_data_train %>% dplyr::select(1:12), lag.max = 40, type = "const")
lagselect$selection

Model1 <- VAR(GB_data_train %>% dplyr::select(1:12), p =40 , type = "const", season = NULL, exog = NULL) 
summary(Model1)

# Test for serial correlation in the residuals 
serial.test(Model1, lags.pt=40, type = "PT.asymptotic")

# Since we reject the null hypothesis that there is no serial correlation the model still has autocorrelation between the errors : there is still variance that is not explained by the model

# Test for causality
#causality(Model1 , cause = "Demand", vcov.=NULL, boot=FALSE, boot.runs=100)

# Make predictions
forecast <- predict(Model1, n.ahead = 81, ci = 0.95)

forecast <- as.data.frame(forecast$fcst) %>% 
  dplyr::select(1,5,9,13,17,21,25,29,33,37,41,45)

forecast <- as.matrix(forecast)

forecast <- as.data.frame(diffinv(forecast, lag=1, xi= as.matrix(GB_data[650,])))

new_names <- colnames(GB_data_test)
old_names <- colnames(forecast)

values = seq(from = as.Date("2020-10-11"), to = as.Date("2020-12-31"), by = 'day')

forecast <- forecast %>% 
rename_at(vars(old_names), ~ new_names) %>% 
mutate(Datetime = values, .before= Biomass) %>% 
slice(2:n()) %>% 
mutate_at(2:8, function(x) ifelse(x<0,0,x))

forecast_dat <- forecast %>% 
  dplyr::select(-1)

test_dat <- original_data %>% 
  slice(651:731) %>% 
  dplyr::select(-1)

# Compute model evaluation metrics
rmse(as.matrix(test_dat), as.matrix(forecast_dat))
mae(as.matrix(test_dat), as.matrix(forecast_dat))

GB_forecast_data <- as.data.frame(rbind(GB_original_data[1:650,], forecast))

# Plot forecast vs actual

ggplot(data= GB_forecast_data %>% 
         mutate(demand_MA= rollmean(Demand, k = 7, fill = NA))
       )+
  geom_line(aes(x= Datetime, y=demand_MA), color="red")+
  geom_line(data= GB_original_data %>% 
              mutate(demand_MA= rollmean(Demand, k = 7, fill = NA))
            ,aes(x= Datetime, y=demand_MA))+
  theme_minimal()+
  labs(
    title= "Forecasted versus actual demand in Great Britain",
    y="Demand (MWh)",
    x=element_blank()
  )+
  theme(plot.title = element_text(size = 16, face = "bold"))


ggplot(data= GB_forecast_data %>% 
         mutate(renewables_MA= rollmean(Renewables, k = 30, fill = NA))
       )+
  geom_line(aes(x= Datetime, y=renewables_MA), color="red")+
  geom_line(data= GB_original_data %>% 
              mutate(renewables_MA= rollmean(Renewables, k = 30, fill = NA))
            ,aes(x= Datetime, y=renewables_MA))+
  theme_minimal()+
  labs(
    title= "Forecasted versus actual generation from Renewables in Great Britain",
    y="Generation from Renewables (MWh)",
    x=element_blank()
  )+
  theme(plot.title = element_text(size = 16, face = "bold"))
  

ggplot(data= GB_forecast_data %>% 
         mutate(fossil_gas_MA= rollmean(Fossil.Gas, k = 30, fill = NA))
       )+
  geom_line(aes(x= Datetime, y=fossil_gas_MA), color="red")+
  geom_line(data= GB_original_data %>% 
              mutate(fossil_gas_MA= rollmean(Fossil.Gas, k = 30, fill = NA))
            ,aes(x= Datetime, y=fossil_gas_MA))+
  theme_minimal()+
  labs(
    title= "Forecasted versus actual generation from Gas in Great Britain",
    y="Generation from Gas (MWh)",
    x=element_blank()
  )+
  theme(plot.title = element_text(size = 16, face = "bold"))


ggplot(data= GB_forecast_data %>% 
         mutate(gbfr_MA= rollmean(GB.FR, k = 30, fill = NA))
       )+
  geom_line(aes(x= Datetime, y=gbfr_MA), color="red")+
  geom_line(data= GB_original_data %>% 
              mutate(gbfr_MA= rollmean(GB.FR, k = 30, fill = NA))
            ,aes(x= Datetime, y= gbfr_MA))+
  theme_minimal()+
  labs(
    title= "Forecasted versus actual trade between Great Britain and France",
    y="Interconnector Flow (MWh)",
    x=element_blank()
  )+
  theme(plot.title = element_text(size = 16, face = "bold"))



forecast$fcst

```

# Univariate Forecasting

```{r fig.height=8, fig.width=12}

# Split into training and test sets
FR_data_train <- FR_data[1:50,] 
FR_data_test <- FR_data[51:60,]

FR_ts <- ts(FR_data_train[, 7], start = c(2016, 1), end = c(2020, 02), frequency = 12)

# Function to calculate mape
mape <- function(actual,pred){
  mape <- mean(abs((actual - pred)/actual))*100
  return (mape)
}

# Building a naive forecasting model 

naive_mod <- naive(FR_ts, h = 12)
summary(naive_mod)

FR_data_test$naive = 45520132
mape(FR_data_test$Renewables, FR_data_test$naive)  #30.932%

# Building an exponential smoothing model

se_model <- ses(FR_ts, h = 10, alpha=0.01)
summary(se_model)

df_fc = as.data.frame(se_model)
FR_data_test$simplexp = df_fc$`Point Forecast`
mape(FR_data_test$Renewables, FR_data_test$simplexp)#18.74%

# Holt's Trend Method

holt_model <- holt(FR_ts, h = 10)
summary(holt_model)

df_holt = as.data.frame(holt_model)
FR_data_test$holt = df_holt$`Point Forecast`
mape(FR_data_test$Renewables, FR_data_test$holt) #25.14%

# ARIMA

arima_model <- auto.arima(FR_ts)
summary(arima_model)

fore_arima = forecast::forecast(arima_model, h=10)
df_arima = as.data.frame(fore_arima)
FR_data_test$arima = df_arima$`Point Forecast`
mape(FR_data_test$Renewables, FR_data_test$arima)  # 12.30596

# TBATS

model_renewables_tbats <- tbats(FR_ts)
summary(model_renewables_tbats)

for_renewables_tbats <- forecast::forecast(model_renewables_tbats, h = 10)
df_renewables_tbats = as.data.frame(for_renewables_tbats)
FR_data_test$renewables_tbats = df_renewables_tbats$`Point Forecast`
mape(FR_data_test$Renewables, FR_data_test$renewables_tbats) # 11.41724

ggplot(data=FR_data_test, aes(x=Datetime, y= Renewables), color= "black") +
  geom_line()+
  geom_line(aes(x=Datetime, y= renewables_tbats), color= "red")

# Making future projections for renewables in France uptill 2025

future_renewables_projections <- forecast::forecast(model_renewables_tbats, h = 60)
p_fore = as.data.frame(future_renewables_projections)

values = seq(from = as.Date("2020-03-01"), to = as.Date("2025-02-01"), by = 'month')

forecast_data <- as.data.frame(cbind.data.frame(values,p_fore$`Point Forecast`))
colnames(forecast_data)[1] <- "Datetime"
colnames(forecast_data)[2] <- "Renewables"
past_data <- FR_data_train %>% dplyr::select(Datetime, Renewables)


rbind.data.frame(past_data,forecast_data) %>% 
  ggplot(aes(x=Datetime, y=Renewables))+
  geom_line()


```

```{r fig.height=8, fig.width=12}

eu_carbon_intensity <- read_xlsx("Total_Carbon_Intensity_2016-2020.xlsx", sheet=5)

# Examine Correlation Between the Final Carbon Intensities at each of the 14 countries
eu_carbon_intensity  %>% 
  dplyr::select(-1) %>% 
  ggcorr(method = c("pairwise", "pearson"), layout.exp = 2,label_round=2, label = TRUE,label_size = 2,hjust = 1,nbreaks = 5,size = 2,angle = -20)

# Visualize the change in carbon intensities over time
eu_carbon_intensity %>% 
  pivot_longer(cols=2:15, names_to="Country", values_to= "carbon_intensity") %>% 
  filter(Country=="GB") %>% 
  ggplot(aes(x=Datetime, y= carbon_intensity))+
  geom_line()


# Run the augmented dickey-fuller test on all time-series to check for stationarity
apply(eu_carbon_intensity %>% dplyr::select(-1),2,adf.test)

GB_data <- eu_carbon_intensity %>% dplyr::select(1,8)
# Split into training and test sets
GB_data_train <- GB_data[1:50,] 
GB_data_test <- GB_data[51:60,]

GB_ts <- ts(GB_data_train[, 2], start = c(2016, 1), end = c(2020, 02), frequency = 12)

# test for autocorrelation 
Acf(GB_ts, lag.max = 20)

#TBATS
model_tbats <- tbats(GB_ts)
summary(model_tbats)

for_tbats <- forecast::forecast(model_tbats, h = 10)
df_tbats = as.data.frame(for_tbats)
GB_data_test$tbats = df_tbats$`Point Forecast`
mape(GB_data_test$GB, GB_data_test$tbats) # 11.41724

ggplot(data=GB_data_test, aes(x=Datetime, y= GB), color= "black") +
  geom_line()+
  geom_line(aes(x=Datetime, y= tbats), color= "red")

future_projections <- forecast::forecast(model_tbats, h = 60)
p_fore = as.data.frame(future_projections)

values = seq(from = as.Date("2020-03-01"), to = as.Date("2025-02-01"), by = 'month')

forecast_data <- as.data.frame(cbind.data.frame(values,p_fore$`Point Forecast`))
colnames(forecast_data)[1] <- "Datetime"
colnames(forecast_data)[2] <- "GB"
past_data <- GB_data_train %>% dplyr::select(Datetime, GB)


rbind.data.frame(past_data,forecast_data) %>% 
  ggplot(aes(x=Datetime, y=GB))+
  geom_line()


```









